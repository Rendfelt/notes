

<<<<<<< HEAD
если засунуть в set 0 и False, останется кто-то один, также работает на True и 1
False == 0			- true
False == 1			- false
True == 1			- true
True == 0			- false
True == 2			- false


для mutable конструкций в python всегда создается новый объект (list, dict, set)


стартовая функция - module


функция, которая ничего не возвращает, возвращает None, type NoneType


передача аргументов в функцию:
	def some_function(a, b):

	some_function(10, 20)			#обычная передача агрументов(позиционная)
	some_function(b = 10, a = 20)	#именная передача
	lst = [20, 10]
	some_function(*lst)				#позиционная передача с помощью списка
	args = {'b': 30, 'a': 40}		
	some_function(**args)			#передача с помошью словаря(именная)
	
	
синтаксически верное определение функции
	def f(arg1, arg2 = 10, *more_args, kwarg4 = 5, kwarg5, **kwargs)
	arg1			позиционный аргумент
	arg2			позиционный аргумент с дефолтным значением
	more_args		остальные позиционные аргументы
	kwarg4			именной аргумент с дефолтным значением 
	kwarg5			именной аргумент
	kwargs			остальные именные аргументы


Классы
	class MyClass:
		a = 10
		b = 20
		
		def classFunction(x):
			print(x)
			

Конструирование объекта
	a = MyClass()
	
	
конструктор объектов
	def __init__(self):
	
	
наследование
	class A(list)		Класс А наследуется от класса лист
	class B(A, C, D)	Класс B наследуется от классов A, C, D
	

проверка является ли классом или наследником
	issubclass(A, B)	Является ли класс А наследником класса B
	
	
проверка является ли классом или наследником
	isinstance(A, B)	Является ли type(А) наследником класса B
	
	
поиск нужного метода или поля в классе-родителе
	class D: pass
	class E: pass
	class B(D, E): pass
	class C: pass
	class A(B, C): pass

	print(A.mro())		Команда mro() выводит порядок, в котором происходит поиск. Поиск идет по порядку вниз по графу.
						Сначала первый предок, потом первый предок предка, потом второй предок предка, потом второй предок.
						Класс object последний.
	
	[<class '__main__.A'>, <class '__main__.B'>, <class '__main__.D'>, 
	 <class '__main__.E'>, <class '__main__.C'>, <class 'object'>]
	
	
вызвать метод суперкласса:
	class A(list):
		def pop(self):
			super(A, self).pop()		То же самое, что вызвать list.pop()


считать input
	n = input()
	
	
разбить строку на подстроки
	str.split()
	

узнать методы и поля класса
	dir(Class)
	
	

